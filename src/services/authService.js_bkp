// src/services/authService.js
import axios from 'axios';
import { API_CONFIG, ENDPOINTS } from '../config/api';
import { saveData, removeData, STORAGE_KEYS } from '../utils/storage';

/**
 * Login del usuario con validaciÃ³n de mÃ³dulos de acceso
 */
export const login = async (identification, pin) => {
  try {
    console.log('=== LOGIN ===');
    console.log('URL:', `${API_CONFIG.BASE_URL}${ENDPOINTS.LOGIN}`);
    console.log('Credentials:', { identification, pin: '****' });
    
    const response = await axios.post(
      `${API_CONFIG.BASE_URL}${ENDPOINTS.LOGIN}`,
      {
        identification: identification,
        pin: pin,
        tenant_id: 1
      },
      { timeout: API_CONFIG.TIMEOUT }
    );

    console.log('Login response:', JSON.stringify(response.data, null, 2));

    if (response.data.success) {
      const userData = response.data.data;
      
      // âœ… VALIDAR MÃ“DULOS DE ACCESO
      const accessModules = validateUserAccess(userData);
      
      console.log('MÃ³dulos de acceso:', accessModules);
      
      // Validar que el usuario tenga al menos un mÃ³dulo
      if (!accessModules.hasAnyAccess) {
        return {
          success: false,
          message: 'Tu cuenta no tiene mÃ³dulos asignados. Contacta al administrador.'
        };
      }
      
      // Agregar mÃ³dulos al userData
      const enhancedUserData = {
        ...userData,
        access: accessModules
      };
      
      console.log('Guardando usuario:', JSON.stringify(enhancedUserData, null, 2));
      await saveData(STORAGE_KEYS.USER, enhancedUserData);
      
      // âœ… CARGAR ZONAS ASIGNADAS AL USUARIO (CON userId)
      if (accessModules.hasAnyAccess) {
        await loadZonesCache(
          userData.tenant_id || 1, 
          userData.client_id,
          userData.car_user_id || userData.user_id // â† AGREGADO
        );
      }
      
      return {
        success: true,
        user: enhancedUserData,
        access: accessModules,
        message: accessModules.getWelcomeMessage()
      };
    } else {
      return {
        success: false,
        message: response.data.error || 'Error en el login'
      };
    }
  } catch (error) {
    console.error('Login error:', error.message);
    console.error('Response:', error.response?.data);
    return {
      success: false,
      message: error.response?.data?.error || 'Error de conexiÃ³n'
    };
  }
};

/**
 * Validar quÃ© mÃ³dulos tiene acceso el usuario
 */
export const validateUserAccess = (userData) => {
  const hasAttendance = userData.has_attendance_access === 1 || 
                       userData.has_attendance_access === true ||
                       userData.has_attendance_access === '1';
                       
  const hasRounds = userData.has_rounds_access === 1 || 
                   userData.has_rounds_access === true ||
                   userData.has_rounds_access === '1';
                   
  const hasSentinel = userData.has_sentinel_access === 1 || 
                     userData.has_sentinel_access === true ||
                     userData.has_sentinel_access === '1';
  
  const isSupervisor = userData.is_supervisor === 1 || 
                      userData.is_supervisor === true ||
                      userData.is_supervisor === '1';
  
  const modules = [];
  if (hasAttendance) modules.push('attendance');
  if (hasRounds) modules.push('rounds');
  if (hasSentinel) modules.push('sentinel');
  
  return {
    hasAttendance,
    hasRounds,
    hasSentinel,
    isSupervisor,
    hasAll: hasAttendance && hasRounds && hasSentinel,
    hasAttendanceAndRounds: hasAttendance && hasRounds && !hasSentinel,
    hasAttendanceAndSentinel: hasAttendance && hasSentinel && !hasRounds,
    hasRoundsAndSentinel: hasRounds && hasSentinel && !hasAttendance,
    hasOnlyAttendance: hasAttendance && !hasRounds && !hasSentinel,
    hasOnlyRounds: hasRounds && !hasAttendance && !hasSentinel,
    hasOnlySentinel: hasSentinel && !hasAttendance && !hasRounds,
    hasAnyAccess: hasAttendance || hasRounds || hasSentinel,
    modules: modules,
    modulesCount: modules.length,
    
    getWelcomeMessage() {
      if (this.hasAll) return 'Acceso completo: Asistencia, Rondas y Tracking';
      if (this.hasAttendanceAndRounds) return 'Acceso: Asistencia y Rondas';
      if (this.hasAttendanceAndSentinel) return 'Acceso: Asistencia y Tracking';
      if (this.hasRoundsAndSentinel) return 'Acceso: Rondas y Tracking';
      if (this.hasOnlyAttendance) return 'Acceso: Solo Asistencia';
      if (this.hasOnlyRounds) return 'Acceso: Solo Rondas';
      if (this.hasOnlySentinel) return 'Acceso: Solo Tracking';
      return 'Sin mÃ³dulos asignados';
    },
    
    getAvailableFeatures() {
      const features = [];
      
      if (this.hasAttendance) {
        features.push({
          id: 'scanner',
          name: 'Escanear',
          icon: 'qrcode-scan',
          route: 'Scanner',
          color: '#3B82F6',
          description: 'Marcar entrada/salida/break'
        });
      }
      
      if (this.hasRounds) {
        features.push({
          id: 'rounds',
          name: 'Rondas',
          icon: 'map-marker-path',
          route: 'Rounds',
          color: '#8B5CF6',
          description: 'Ver y completar rondas asignadas'
        });
      }
      
      if (this.hasOnlySentinel) {
        features.push({
          id: 'sentinel',
          name: 'Tracking',
          icon: 'crosshairs-gps',
          route: 'Sentinel',
          color: '#10B981',
          description: 'Tracking GPS en tiempo real'
        });
      }
      
      if (this.hasAnyAccess) {
        features.push({
          id: 'history',
          name: 'Historial',
          icon: 'history',
          route: 'History',
          color: '#64748B',
          description: 'Ver marcas del dÃ­a'
        });
      }
      
      if (this.isSupervisor && this.hasAttendance) {
        features.push({
          id: 'admin_nfc',
          name: 'Admin NFC',
          icon: 'nfc-variant',
          route: 'AdminNFC',
          color: '#F59E0B',
          description: 'Configurar tags NFC'
        });
      }
      
      return features;
    },
    
    shouldStartGPSTracking() {
      return this.hasSentinel;
    },
    
    getModuleColor() {
      if (this.hasAll) return '#10B981';
      if (this.modulesCount === 2) return '#3B82F6';
      if (this.modulesCount === 1) return '#F59E0B';
      return '#64748B';
    }
  };
};

/**
 * âœ… CORREGIDO: Cargar zonas ASIGNADAS AL USUARIO
 */
export const loadZonesCache = async (tenantId = 1, clientId = null, userId = null) => {
  try {
    console.log('ðŸ”„ Cargando zonas del usuario:', userId);
    
    // âœ… IMPORTANTE: Usar endpoint que devuelve zonas del usuario
    const params = { 
      tenant_id: tenantId,
      user_id: userId
    };
    
    if (clientId) params.client_id = clientId;
    
    const queryString = new URLSearchParams(params).toString();
    const url = `${API_CONFIG.BASE_URL}${ENDPOINTS.USER_ZONES}?${queryString}`;
    
    console.log('ðŸ“¡ URL zonas:', url);
    
    const response = await axios.get(url, { timeout: 10000 });
    
    console.log('ðŸ“¥ Respuesta zonas:', response.data);
    
    if (response.data.success && Array.isArray(response.data.data)) {
      const zones = response.data.data;
      console.log(`âœ… ${zones.length} zonas asignadas cargadas`);
      
      // Separar zonas por tipo
      const zonesByType = {
        attendance: zones.filter(z => z.is_attendance_zone),
        rounds: zones.filter(z => z.is_rounds_zone),
        sentinel: zones.filter(z => z.is_sentinel_zone),
        all: zones
      };
      
      // Guardar en cache
      await saveData(STORAGE_KEYS.ZONES, zonesByType);
      await saveData(STORAGE_KEYS.ZONES_LAST_UPDATE, new Date().toISOString());
      
      // Log importante
      console.log('ðŸ“Š Zonas por tipo:', {
        attendance: zonesByType.attendance.length,
        rounds: zonesByType.rounds.length,
        sentinel: zonesByType.sentinel.length
      });
      
      // âœ… Log de zona Sentinel especÃ­fica
      if (zonesByType.sentinel.length > 0) {
        const sentinelZone = zonesByType.sentinel[0];
        console.log('ðŸŽ¯ Zona Sentinel asignada:', sentinelZone.zone_name, `(ID: ${sentinelZone.zone_id})`);
      } else {
        console.warn('âš ï¸ Usuario sin zona Sentinel asignada');
      }
      
      return { 
        success: true, 
        count: zones.length,
        byType: {
          attendance: zonesByType.attendance.length,
          rounds: zonesByType.rounds.length,
          sentinel: zonesByType.sentinel.length
        }
      };
    } else {
      console.warn('âš ï¸ Respuesta de zonas invÃ¡lida');
      return { success: false, message: 'Formato de respuesta invÃ¡lido' };
    }
  } catch (error) {
    console.error('âŒ Error cargando zonas:', error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    return { success: false, message: error.message };
  }
};

/**
 * Cerrar sesiÃ³n
 */
export const logout = async () => {
  try {
    await removeData(STORAGE_KEYS.USER);
    await removeData(STORAGE_KEYS.LAST_ACTION);
    await removeData(STORAGE_KEYS.ZONES);
    await removeData(STORAGE_KEYS.ZONES_LAST_UPDATE);
    await removeData(STORAGE_KEYS.PENDING_MARKS);
    await removeData(STORAGE_KEYS.PENDING_GPS);
    await removeData(STORAGE_KEYS.LAST_GPS_POSITION);
    await removeData(STORAGE_KEYS.GPS_TRACKING_ACTIVE);
    return { success: true };
  } catch (error) {
    console.error('Logout error:', error);
    return { success: false };
  }
};

/**
 * Validar PIN del usuario
 */
export const validatePin = async (userId, pin, tenantId = 1) => {
  try {
    const response = await axios.post(
      `${API_CONFIG.BASE_URL}${ENDPOINTS.VALIDATE_PIN}`,
      {
        user_id: userId,
        pin: pin,
        tenant_id: tenantId
      },
      { timeout: 5000 }
    );
    
    return response.data.is_valid || false;
  } catch (error) {
    console.error('Error validando PIN:', error);
    return false;
  }
};
