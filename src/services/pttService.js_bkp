// src/services/pttService.js - VERSI√ìN FINAL ANDROID ZEBRA
import * as Notifications from 'expo-notifications';

let notificationId = null;
import * as FileSystem from 'expo-file-system';
import { Audio } from 'expo-av';
import { Vibration } from 'react-native';
import { io } from 'socket.io-client';

// ========================================
// CONFIGURACI√ìN
// ========================================

const PTT_SERVER_URL = 'https://ptt.suppcenter.global:3001';
const SAMPLE_RATE = 16000;

let socket = null;
let recording = null;
let sound = null;
let isRecording = false;
let listeners = [];
let activeUsers = [];
let currentSpeaker = null;

// ========================================
// INICIALIZACI√ìN
// ========================================

export const initializePTT = async (user) => {
  try {
    console.log('üéôÔ∏è Inicializando PTT...');
    
    // Permisos de audio
    const { status } = await Audio.requestPermissionsAsync();
    if (status !== 'granted') {
      return { success: false, message: 'Permisos denegados' };
    }
    console.log('‚úÖ Permisos OK');
    
    await Audio.setAudioModeAsync({
      staysActiveInBackground: true,
      shouldDuckAndroid: true,
      playThroughEarpieceAndroid: false,
    });
    
    // ‚úÖ NOTIFICACI√ìN PERSISTENTE
    try {
      await Notifications.setNotificationChannelAsync('ptt-service', {
        name: 'PTT Service',
        importance: Notifications.AndroidImportance.LOW,
        sound: false,
        vibrationPattern: [0],
      });
      
      notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title: 'üéôÔ∏è PTT Activo',
          body: 'Walkie-Talkie conectado',
          sticky: true,
        },
        trigger: null,
      });
      
      console.log('üì± Notificaci√≥n creada');
    } catch (e) {
      console.log('‚ö†Ô∏è Error notificaci√≥n:', e.message);
    }
    
    // ‚úÖ SOCKET CON KEEP-ALIVE AGRESIVO
    socket = io(PTT_SERVER_URL, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      
      // ‚úÖ CR√çTICO: PING/PONG M√ÅS FRECUENTE
      pingInterval: 5000,  // Ping cada 5 segundos
      pingTimeout: 10000,  // Timeout de 10 segundos
      
      // ‚úÖ UPGRADE A WEBSOCKET INMEDIATAMENTE
      upgrade: true,
      rememberUpgrade: true,
      transports: ['websocket'],
    });
    
    // ‚úÖ KEEP-ALIVE MANUAL (POR SI ACASO)
    let keepAliveInterval;
    
    socket.on('connect', () => {
      console.log('‚úÖ PTT conectado:', socket.id);
      
      const channelId = `tenant_${user.tenant_id}_client_${user.client_id}`;
      socket.emit('join_channel', {
        userId: user.car_user_id || user.user_id,
        userName: user.name || `${user.first_name} ${user.last_name}`,
        tenantId: user.tenant_id,
        clientId: user.client_id,
        channelId
      });
      
      // ‚úÖ PING MANUAL CADA 3 SEGUNDOS
      if (keepAliveInterval) clearInterval(keepAliveInterval);
      keepAliveInterval = setInterval(() => {
        if (socket && socket.connected) {
          socket.emit('ping', { timestamp: Date.now() });
        }
      }, 3000);
      
      notifyListeners('connected');
    });
    
    socket.on('pong', (data) => {
      // Respuesta del servidor - conexi√≥n viva
    });
    
    socket.on('connect_error', (error) => {
      console.log('‚ùå Error conexi√≥n:', error.message);
    });
    
    socket.on('disconnect', (reason) => {
      console.log('üîå Desconectado:', reason);
      
      if (keepAliveInterval) {
        clearInterval(keepAliveInterval);
      }
      
      if (reason === 'io server disconnect') {
        socket.connect();
      }
      
      notifyListeners('disconnected');
    });
    
    socket.on('reconnect', (attemptNumber) => {
      console.log('üîÑ Reconectado:', attemptNumber);
    });
    
    socket.on('audio_receive', async (data) => {
      console.log('üîä Audio recibido');
      await playAudio(data.audioData);
    });
    
    socket.on('user_speaking', (data) => {
      currentSpeaker = data.speaking ? data.userName : null;
      notifyListeners('speaker_changed', currentSpeaker);
      if (data.speaking) Vibration.vibrate(100);
    });
    
    socket.on('active_users', (users) => {
      activeUsers = users;
      notifyListeners('users_updated', users);
    });
    
    socket.on('user_joined', (data) => {
      console.log(`üë§ ${data.userName} se uni√≥`);
      notifyListeners('user_joined', data);
    });
    
    socket.on('user_left', (data) => {
      console.log(`üëã ${data.userName} sali√≥`);
      notifyListeners('user_left', data);
    });
    
    return { success: true, message: 'PTT OK' };
    
  } catch (error) {
    console.error('‚ùå Error init:', error);
    return { success: false, message: error.message };
  }
};

// ========================================
// GRABAR AUDIO
// ========================================

export const startRecording = async (user) => {
  if (isRecording) {
    console.log('‚ö†Ô∏è Ya est√° grabando');
    return { success: false };
  }
  
  try {
    console.log('üî¥ INICIANDO GRABACI√ìN PTT...');
    
    // ‚úÖ MARCAR COMO GRABANDO INMEDIATAMENTE
    isRecording = true;
    notifyListeners('recording_started');
    
    // Notificar al servidor
    socket?.emit('ptt_pressed', {
      userId: user.car_user_id || user.user_id,
      userName: user.name || `${user.first_name} ${user.last_name}`
    });
    
    Vibration.vibrate(200);
    
    // Crear recording
    recording = new Audio.Recording();
    console.log('üì± Recording creado');
    
    // ‚úÖ USAR VALORES NUM√âRICOS DIRECTOS (M√ÅS CONFIABLE)
    await recording.prepareToRecordAsync({
      android: {
        extension: '.m4a',
        outputFormat: 2,  // MPEG_4
        audioEncoder: 3,  // AAC
        sampleRate: SAMPLE_RATE,
        numberOfChannels: 1,
        bitRate: 32000,
      },
      ios: {
        extension: '.m4a',
        outputFormat: 1,  // MPEG4AAC
        audioQuality: 0,  // LOW
        sampleRate: SAMPLE_RATE,
        numberOfChannels: 1,
        bitRate: 32000,
      },
    });
    console.log('üì± Recording preparado');
    
    await recording.startAsync();
    console.log('‚úÖ GRABACI√ìN ACTIVA');
    
    return { success: true };
    
  } catch (error) {
    console.error('‚ùå ERROR INICIANDO GRABACI√ìN:', error);
    console.error('‚ùå Error details:', JSON.stringify(error));
    
    // Resetear estado si falla
    isRecording = false;
    recording = null;
    notifyListeners('recording_error');
    
    return { success: false, error: error.message };
  }
};

// ========================================
// DETENER GRABACI√ìN
// ========================================

export const stopRecording = async (user) => {
  if (!isRecording || !recording) {
    console.log('‚ö†Ô∏è No hay grabaci√≥n activa');
    return { success: false };
  }
  
  try {
    console.log('‚ö™ DETENIENDO GRABACI√ìN PTT...');
    
    await recording.stopAndUnloadAsync();
    const uri = recording.getURI();
    console.log('üìÅ URI del audio:', uri);
    
    isRecording = false;
    recording = null;
    
    socket?.emit('ptt_released', {
      userId: user.car_user_id || user.user_id,
      userName: user.name || `${user.first_name} ${user.last_name}`
    });
    
    Vibration.vibrate(100);
    notifyListeners('recording_stopped');
    
    // Enviar audio al servidor
    if (uri) {
      try {
        console.log('üì§ Procesando audio...');
        
        const response = await fetch(uri);
        const blob = await response.blob();
        
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        
        reader.onloadend = () => {
          const base64Audio = reader.result.split(',')[1];
          
          if (base64Audio && socket?.connected) {
            socket.emit('audio_stream', {
              audioData: base64Audio,
              userId: user.car_user_id || user.user_id,
              userName: user.name || `${user.first_name} ${user.last_name}`,
              timestamp: Date.now()
            });
            
            console.log('‚úÖ Audio enviado al servidor:', (base64Audio.length / 1024).toFixed(2), 'KB');
          } else {
            console.log('‚ö†Ô∏è No se pudo enviar audio o socket desconectado');
          }
        };
        
        reader.onerror = (error) => {
          console.error('‚ùå Error leyendo archivo de audio:', error);
        };
        
      } catch (e) {
        console.error('‚ùå Error procesando audio:', e);
      }
    }
    
    return { success: true };
    
  } catch (error) {
    console.error('‚ùå Error deteniendo grabaci√≥n:', error);
    isRecording = false;
    recording = null;
    notifyListeners('recording_stopped');
    return { success: false, error: error.message };
  }
};

// ========================================
// REPRODUCIR AUDIO RECIBIDO
// ========================================

const playAudio = async (base64Audio) => {
  try {
    console.log('üîä Reproduciendo audio recibido...');
    
    if (sound) {
      await sound.unloadAsync();
      sound = null;
    }
    
    // ‚úÖ CONVERTIR BASE64 A BLOB (M√âTODO QUE S√ç FUNCIONA EN RN)
    const byteCharacters = atob(base64Audio);
    const byteNumbers = new Array(byteCharacters.length);
    
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    
    const byteArray = new Uint8Array(byteNumbers);
    
    // ‚úÖ CREAR DATA URI DIRECTAMENTE
    const dataUri = `data:audio/m4a;base64,${base64Audio}`;
    
    console.log('üéµ Creando sonido desde data URI...');
    
    // Reproducir desde data URI
    const { sound: newSound } = await Audio.Sound.createAsync(
      { uri: dataUri },
      { shouldPlay: true, volume: 1.0 }
    );
    
    sound = newSound;
    
    sound.setOnPlaybackStatusUpdate((status) => {
      if (status.didJustFinish) {
        console.log('‚úÖ Reproducci√≥n finalizada');
        sound.unloadAsync();
        sound = null;
      }
    });
    
    console.log('‚úÖ Audio reproduciendo correctamente');
    
  } catch (error) {
    console.error('‚ùå Error reproduciendo audio:', error.message);
  }
};

// ========================================
// UTILIDADES
// ========================================

export const subscribe = (callback) => {
  listeners.push(callback);
  return () => {
    listeners = listeners.filter(cb => cb !== callback);
  };
};

const notifyListeners = (event, data = null) => {
  listeners.forEach(callback => {
    try {
      callback({ event, data });
    } catch (error) {
      console.error('Error en listener PTT:', error);
    }
  });
};

export const getActiveUsers = () => activeUsers;
export const getCurrentSpeaker = () => currentSpeaker;
export const isConnected = () => socket?.connected || false;

export const disconnectPTT = async () => {
  if (socket) {
    socket.disconnect();
    socket = null;
  }
  
  if (recording) {
    await recording.stopAndUnloadAsync();
    recording = null;
  }
  
  if (sound) {
    await sound.unloadAsync();
    sound = null;
  }
  
  // ‚úÖ LIMPIAR NOTIFICACI√ìN
  if (notificationId) {
    await Notifications.dismissNotificationAsync(notificationId);
    notificationId = null;
  }
  
  isRecording = false;
  listeners = [];
  activeUsers = [];
  currentSpeaker = null;
  
  console.log('üîå PTT desconectado completamente');
};
